////////////////////////////////////////////////////////////////////////////////
//	OV		MAJOR MODE 4 (LINEAR GUIDANCE ASCENT)
////////////////////////////////////////////////////////////////////////////////
// SPECIFIC GRAVITY CONSTANT FOR ASCENT BODY
GLOBAL MU IS CONSTANT:G * KERBIN:MASS.

// FIX DEFICIENCIES IN KOS MATH LIBRARY
FUNCTION RAD { PARAMETER X.		RETURN CONSTANT:PI*X/180.0. }
FUNCTION DEG { PARAMETER X.		RETURN 180.0*X/CONSTANT:PI. }
FUNCTION ACOS { PARAMETER X.	RETURN RAD(ARCCOS(MAX(-1, MIN(1, X )) )). }
FUNCTION EXP { PARAMETER X.		RETURN CONSTANT:E^X. }


////////////////////////////////////////////////////////////////////////////////
// GUIDANCE MODE (1: SINGLE STAGE, 2: BISTAGE)
GLOBAL GUIDANCE_MODE	IS 1.

// STAGE 1 (CONSTANT THRUST)
//	ENGINE THRUST (FOR PERFORMANCE ESTIMATION)
GLOBAL STAGE1_F			IS 650000*0.45.
//	ENGINE ISP (FOR PERFORMANCE ESTIMATION)
GLOBAL STAGE1_ISP		IS 320.
//	TOTAL FUEL ON STAGE 1 FOR ESTIMATING BURN TIME
GLOBAL STAGE1_FUEL		IS 14400 + 17600.
// == DERIVED PARAMETERS ==
GLOBAL STAGE1_VE		IS 9.81*STAGE1_ISP.					// EXHAUST VELOCITY
GLOBAL STAGE1_FF		IS STAGE1_F*(0.101972/STAGE1_ISP).	// FUEL FLOW
GLOBAL STAGE1_BURNTIME	IS (STAGE1_FUEL/STAGE1_FF)*1.01.	// BURN TIME IN SECONDS

// STAGE 2 (CONSTANT ACCELERATION)
//	CONSTANT ACCELERATION DURING STAGE 2
GLOBAL STAGE2_A0		IS 0.

// TARGET PARAMETERS
//	TARGET PERIAPSIS
GLOBAL TARGET_PE		IS KERBIN:RADIUS -  50000.0.
//	TARGET APOAPSIS
GLOBAL TARGET_AP		IS KERBIN:RADIUS + 120000.0.
//	TARGET TRUE ANOMALY (IN DEGREES)
GLOBAL TARGET_TA		IS 180.
// == DERIVED PARAMETERS ==
GLOBAL TARGET_E 		IS (TARGET_AP - TARGET_PE) / (TARGET_AP + TARGET_PE).
GLOBAL TARGET_A			IS TARGET_AP/(1+TARGET_E).
GLOBAL TARGET_P			IS 2*TARGET_AP*TARGET_PE/(TARGET_AP+TARGET_PE).
GLOBAL TARGET_H			IS (MU*TARGET_P)^0.5.
GLOBAL TARGET_V			IS ((MU/TARGET_P)^0.5)*TARGET_E*SIN(TARGET_TA).
GLOBAL TARGET_R			IS TARGET_P/(1+TARGET_E*COS(TARGET_TA)).


////////////////////////////////////////////////////////////////////////////////
// STATE VARIABLES
GLOBAL OMEGA			IS 0.				// ANGULAR VELOCITY IN INERTIAL COORDINATES
GLOBAL V0s_0			IS 0.				// RADIAL VELOCITY OF THE CURRENT STAGE
GLOBAL R0s_0			IS 0.				// RADIAL POSITION OF THE CURRENT STAGE

// GUIDANCE VARIABLES
GLOBAL CUTOFF_TIME		IS 0.					// COMPUTED TIME TO CUTOFF
GLOBAL STAGE1_A0		IS 0.					// STAGE 1 ACCELERATION AT CURRENT POINT
GLOBAL STAGE1_TAU		IS 0.					// STAGE 1 PREDICTED SPECIFIC CONSTANT
GLOBAL STAGE1_T			IS STAGE1_BURNTIME.		// CUTOFF TIME FOR STAGE 1
GLOBAL STAGE2_T			IS STAGE1_BURNTIME*1.5.	// CUTOFF TIME FOR STAGE 2

GLOBAL TAB				IS 0. 					// TIME OF A/B STEERING CONSTANTS
GLOBAL A				IS 0. 					// CURRENT VALUE OF A STEERING CONSTANT
GLOBAL B				IS 0. 					// CURRENT VALUE OF B STEERING CONSTANT
GLOBAL A_1				IS 0. 					// LAST ESTIMATE FOR A1 STEERING CONSTANT
GLOBAL B_1				IS 0. 					// LAST ESTIMATE FOR B1 STEERING CONSTANT

GLOBAL PITCH 			IS 0. 					// PITCH COMPUTED FIXME


////////////////////////////////////////////////////////////////////////////////
// THRUST INTEGRALS
FUNCTION A0_1 { PARAMETER T. RETURN STAGE1_A0/(1 - T/STAGE1_TAU).						}
FUNCTION A0_2 { PARAMETER T. RETURN STAGE2_A0.											}
FUNCTION B0_1 { PARAMETER T. RETURN -STAGE1_VE * LN(MAX(1 - T/STAGE1_TAU, 0.01)).		}
FUNCTION B0_2 { PARAMETER T. RETURN STAGE2_A0 * T.										}
FUNCTION B1_1 { PARAMETER T. RETURN B0_1(T)*STAGE1_TAU - STAGE1_VE*T.					}
FUNCTION B1_2 { PARAMETER T. RETURN STAGE2_A0 * (T^2)/2.								}
FUNCTION C0_1 { PARAMETER T. RETURN B0_1(T)*T - B1_1(T).								}
FUNCTION C0_2 { PARAMETER T. RETURN STAGE2_A0 * (T^2)/2.								}
FUNCTION C1_1 { PARAMETER T. RETURN C0_1(T)*STAGE1_TAU - STAGE1_VE*(T^2)/2.				}
FUNCTION C1_2 { PARAMETER T. RETURN STAGE2_A0 * (T^3)/6.								}

// DISCONTINUITIES
FUNCTION dA { // A2 - A1
	LOCAL R IS R0s_2().
	RETURN (MU/(R^2) - (OMEGA^2)*R) * (1/A0_1(STAGE1_T) - 1/A0_2(0)).
}
FUNCTION dB { // B2 - B1
	LOCAL R IS R0s_2().
	LOCAL V IS V0s_2().
	RETURN
		//-(MU/(R^2) - (OMEGA^2)*R) * (1/STAGE1_VE - 1/STAGE2_VE)  (NOT USED, STAGE1_VE = STAGE2_VE)
		+((3*(OMEGA^2) - 2*MU/(R^3))*V) * (1/A0_1(STAGE1_T) - 1/A0_2(0)).
}

// STEERING CONSTANTS FOR STAGE 2
FUNCTION A_2 {	RETURN A_1 + dA() + B_1*STAGE1_T.	}
FUNCTION B_2 {	RETURN B_1 + dB().					}

// RADIAL VELOCITY AT THE BEGINNING OF STAGE BURN
FUNCTION V0s_1 {
	RETURN V0s_0.
}
FUNCTION V0s_2 {
	IF MINOR_MODE = 1 {
		RETURN V0s_0. // CURRENT STAGE 2 VELOCITY
	} ELSE {
		RETURN B0_1(STAGE1_T)*A_1 + B1_1(STAGE1_T)*B_1. // PREDICTED VELOCITY
	}
}

// RADIAL POSITION AT THE BEGINNING OF STAGE BURN
FUNCTION R0s_1 {
	RETURN R0s_0.
}
FUNCTION R0s_2 {
	IF MINOR_MODE = 1 {
		RETURN R0s_0. // CURRENT STAGE 2 POSITION
	} ELSE {
		RETURN V0s_2()*STAGE1_T + C0_1(STAGE1_T)*A_1 + C1_1(STAGE1_T)*B_1. // PREDICTED POSITION
	}
}


////////////////////////////////////////////////////////////////////////////////
// SOLVE LINEAR GUIDANCE EQUATIONS FOR TWO-STAGE FLIGHT
FUNCTION LG_SOLVE_2STAGE {
	// V(T) = UV*A1 + VV*B1 + WV
	LOCAL UV IS B0_1(STAGE1_T) + B0_2(STAGE2_T).
	LOCAL VV IS B1_1(STAGE1_T) + 
				B1_2(STAGE2_T) + B0_2(STAGE2_T)*STAGE1_T.
	LOCAL WV IS B0_2(STAGE2_T)*dA() + B1_2(STAGE2_T)*dB() + 
				V0s_0.
	
	// R(T) = UR*A1 + VR*B1 + WR
	LOCAL UR IS C0_1(STAGE1_T) + 
				C0_2(STAGE2_T) + B0_1(STAGE1_T)*STAGE2_T.
	LOCAL VR IS C1_1(STAGE1_T) + 
				C1_2(STAGE2_T) + C0_2(STAGE1_T)*STAGE1_T + B1_1(STAGE1_T)*STAGE2_T.
	LOCAL WR IS C0_2(STAGE2_T)*dA() + C1_2(STAGE2_T)*dB() +
				R0s_0 + V0s_0*(STAGE1_T + STAGE2_T).
	
	// SOLVE LINEAR EQUATION
	LOCAL C1 IS TARGET_V - WV.
	LOCAL C2 IS TARGET_R - WR.

	LOCAL DET_D IS UV*VR-VV*UR.
	LOCAL DET_A IS VR*C1-C2*VV.
	LOCAL DET_B IS UV*C2-C1*UR.
	
	// GET STEERING CONSTANTS
	SET A_1 TO DET_A / DET_D.
	SET B_1 TO DET_B / DET_D.
}

// SOLVE EQUATIONS FOR ONE-STAGE FLIGHT
FUNCTION LG_SOLVE_1STAGE {
	// V(T) = UV*A1 + VV*B1 + WV
	LOCAL UV IS B0_1(STAGE1_T).
	LOCAL VV IS B1_1(STAGE1_T).
	LOCAL WV IS V0s_0.
	
	// R(T) = UR*A1 + VR*B1 + WR
	LOCAL UR IS C0_1(STAGE1_T).
	LOCAL VR IS C1_1(STAGE1_T).
	LOCAL WR IS R0s_0 + V0s_0*STAGE1_T.
	
	// SOLVE LINEAR EQUATION
	LOCAL C1 IS TARGET_V - WV.
	LOCAL C2 IS TARGET_R - WR.

	LOCAL DET_D IS UV*VR-VV*UR.
	LOCAL DET_A IS VR*C1-C2*VV.
	LOCAL DET_B IS UV*C2-C1*UR.
	
	// GET STEERING CONSTANTS
	SET A_1 TO DET_A / DET_D.
	SET B_1 TO DET_B / DET_D.
}


////////////////////////////////////////////////////////////////////////////////
FUNCTION MM4_ENTER {
	//ENABLE_THROTTLE().
	//GLOBAL TBIAS IS TIME:SECONDS.		// SET TIME BIAS
	
	ENABLE_STEERING().
	SET CURRENT_STEERING TO HEADING(90, 90).
}

FUNCTION MM4_LEAVE {
	DISABLE_STEERING().
}


////////////////////////////////////////////////////////////////////////////////
// MAJOR LOOP: RECOMPUTES STEERING CONSTANTS AND DOES THE HEAVY CALCULATIONS
////////////////////////////////////////////////////////////////////////////////
FUNCTION MM4_MAJOR_LOOP_TASK { PARAMETER DT.
	// AXES OF THE SOI-CENTRIC INERTIAL COORDINATE SYSTEM (ALL VECS IN SHIP:RAW)
	LOCAL ORIGIN IS SHIP:BODY:POSITION.
	LOCAL IX IS (LATLNG( 0, 0):POSITION - ORIGIN):NORMALIZED. // X AXIS (ZERO)
	LOCAL IY IS (LATLNG( 0,90):POSITION - ORIGIN):NORMALIZED. // Y AXIS (EAST)
	LOCAL IZ IS (LATLNG(90, 0):POSITION - ORIGIN):NORMALIZED. // Z AXIS (NORTH)

	// INERTIAL POSITION AND VELOCITY
	LOCAL VR0 IS SHIP:POSITION - ORIGIN.						// POSITION IN SHIP:RAW
	LOCAL VV0 IS SHIP:VELOCITY:ORBIT.							// VELOCITY IN SHIP:RAW
	LOCAL VR IS V(VDOT(VR0, IX), VDOT(VR0, IY), VDOT(VR0, IZ)). // POSITION IN INERTIAL
	LOCAL VV IS V(VDOT(VV0, IX), VDOT(VV0, IY), VDOT(VV0, IZ)).	// VELOCITY IN INERTIAL
	LOCAL HV IS VCRS(VR, VV).									// ORBITAL ANGULAR MOMENTUM
	
	// CALCULATE AXES AND POSITION VECTORS FOR THE COORDINATE SYSTEM
	LOCAL R IS VR:NORMALIZED.
	LOCAL V IS VV:NORMALIZED.
	LOCAL H IS HV:NORMALIZED.
	LOCAL TG IS VCRS(H,R).		// TANGENTIAL VECTOR
	
	LOCAL VRAD IS VDOT(VV, R).	// RADIAL VELOCITY
	LOCAL VTAN IS VDOT(VV, TG).	// TANGENTIAL VELOCITY
	
	SET R0s_0 TO VR:MAG.		// CURRENT POSITION
	SET V0s_0 TO VRAD.			// CURRENT RADIAL VELOCITY
	SET OMEGA TO VTAN/VR:MAG.	// ANGULAR VELOCITY (IN INERTIAL COORDINATES)
	LOCAL HMAG IS HV:MAG.		// ANGULAR MOMENTUM

	// ESTIMATE RESIDUAL VELOCITY
	LOCAL DV IS (TARGET_H - HMAG)/((R0s_0 + TARGET_R)*0.5).
	
	// RUN GUIDANCE
	IF GUIDANCE_MODE = 1 { // ONE-STAGE GUIDANCE		
		// CALCULATE STAGE PHYSICS PARAMETERS
		LOCAL TOTAL_MASS IS SHIP:MASS*1000.
		SET STAGE1_A0 TO STAGE1_F / TOTAL_MASS.
		SET STAGE1_TAU TO STAGE1_VE / STAGE1_A0.

		// ESTIMATE CUTOFF TIME BY REMAINING DV
		SET STAGE1_T TO STAGE1_TAU*(1 - EXP(-DV/STAGE1_VE)).
		SET CUTOFF_TIME TO STAGE1_T.
		
		// SOLVE LINEAR GUIDANCE EQUATIONS (ONE-STAGE)
		LG_SOLVE_1STAGE().
	}
	
	// UPDATE STEERING CONSTANTS
	SET TAB TO TIME:SECONDS.
	IF MINOR_MODE = 0 { // STAGE 1
		SET A TO A_1.
		SET B TO B_1.
	} ELSE { // STAGE 2
		SET A TO A_2().
		SET B TO B_2().
	}
	
	//--------------------------------------------------------------------------
	// SHOW UI VARIABLES
	UI_VARIABLE("Vrad", "M/S",		VRAD, 			1,8, SIGNED, 0,0).
	UI_VARIABLE("Vtan", "M/S",		VTAN, 			1,8, SIGNED, 0,1).
	UI_VARIABLE("W   ", "RAD/S",	OMEGA, 			1,8, SIGNED, 0,2).
	
	UI_VARIABLE("R   ", "M",		R0s_0, 			0,8, NUMBER, 0,3).
	UI_VARIABLE("Rdot", "M/S",		V0s_0, 			1,8, SIGNED, 0,4).
	UI_VARIABLE("-V  ", "M/S",		DV, 			1,8, NUMBER, 0,5).
	UI_VARIABLE("Rt", "",			TARGET_R, 		0,8, NUMBER, 19,3).
	UI_VARIABLE("Vt", "",			TARGET_V, 		0,8, SIGNED, 19,4).
	
	UI_VARIABLE("1   T", "SEC",		STAGE1_T, 		1,8, SIGNED, 0,7).
	UI_VARIABLE("1  A0", "SEC",		STAGE1_A0, 		1,8, SIGNED, 0,8).
	UI_VARIABLE("1 TAU", "SEC",		STAGE1_TAU, 	1,8, SIGNED, 0,9).
	UI_VARIABLE("2   T", "SEC",		STAGE2_T, 		1,8, SIGNED, 0,10).
	
	UI_VARIABLE("A", "",			A, 				6,8, SIGNED, 0,12).
	UI_VARIABLE("B", "",			B, 				6,8, SIGNED, 0,13).

	// RUN TASK AT HIGHER RATE AS CUTOFF APPROACHES
	IF CUTOFF_TIME > 60.0 {
		TASK_SCHEDULE(6, MM4_MAJOR_LOOP_TASK@).
	} ELSE IF CUTOFF_TIME > 30.0 {
		TASK_SCHEDULE(5, MM4_MAJOR_LOOP_TASK@).
	} ELSE {
		TASK_SCHEDULE(4, MM4_MAJOR_LOOP_TASK@).	
	}
}


////////////////////////////////////////////////////////////////////////////////
// MINOR LOOP: COMPUTES STEERING COMMAND AND STEERS THE ROCKET
////////////////////////////////////////////////////////////////////////////////
FUNCTION MM4_MINOR_LOOP_TASK { PARAMETER DT.
	// DO NOT RUN MINOR LOOP UNTIL INITIALIZED
	IF TAB < 1 { RETURN. }
	
	// DETERMINE AMOUNT OF SECONDS FROM LAST STEERING CONSTANT UPDATE FOR EXTRAPOLATION
	LOCAL T IS TIME:SECONDS - TAB.

	// DETERMINE COORDINATES. SEE MAJOR LOOP FOR EXPLANATION OF THESE CALCULATIONS
	LOCAL ORIGIN IS SHIP:BODY:POSITION.
	LOCAL IX IS (LATLNG( 0, 0):POSITION - ORIGIN):NORMALIZED.
	LOCAL IY IS (LATLNG( 0,90):POSITION - ORIGIN):NORMALIZED.
	LOCAL IZ IS (LATLNG(90, 0):POSITION - ORIGIN):NORMALIZED.
	LOCAL VR0 IS SHIP:POSITION - ORIGIN.
	LOCAL VV0 IS SHIP:VELOCITY:ORBIT.
	LOCAL VR IS V(VDOT(VR0, IX), VDOT(VR0, IY), VDOT(VR0, IZ)).
	LOCAL VV IS V(VDOT(VV0, IX), VDOT(VV0, IY), VDOT(VV0, IZ)).
	LOCAL HV IS VCRS(VR, VV).
	LOCAL R IS VR:NORMALIZED.
	LOCAL H IS HV:NORMALIZED.
	LOCAL TG IS VCRS(H,R).
	LOCAL VTAN IS VDOT(VV, TG).
	LOCAL RMAG IS VR:MAG.
	SET OMEGA TO VTAN/VR:MAG.
	// (FIXME: OPTIMIZE THESE CALCULATIONS)
	
	// COMPUTE STEERING CONSTANT C (GRAVICOMPONENT)
	LOCAL C IS 0.
	IF MINOR_MODE = 0 { // STAGE 1
		SET C TO (MU/(RMAG^2)-(OMEGA^2)*RMAG)/A0_1(T).
	} ELSE { // STAGE 2
		SET C TO (MU/(RMAG^2)-(OMEGA^2)*RMAG)/A0_2(T).
	}
	
	// COMPUTE STEERING COMMAND. THE GOOD STUFF
	LOCAL F IS A + B*T + C.
	
	// ATMOSPHERIC TEST
	IF ALTITUDE > 28000 { LOCK THROTTLE TO 0.45. }
	
	// GENERATE PITCH COMMAND (FIXME: FREEZE STEERING CONSTANTS, NOT PITCH ANGLE...)
	IF CUTOFF_TIME > 7 {
		SET PITCH TO DEG(CONSTANT:PI*0.5 - ACOS(F)).
	}
	
	// GENERATE CUTOFF SIGNAL
	IF CUTOFF_TIME < 5 { // CUTOFF ARMED
		LOCAL HMAG IS HV:MAG.
		LOCAL DV IS (TARGET_H - HMAG)/((R0s_0 + TARGET_R)*0.5).
		IF DV < 2 { // SHUTDOWN ENGINES WHEN CUTOFF REACHED
			LOCK THROTTLE TO 0.0.
		}
		
		// FIXME: PERFORMANCE CAN BE IMPROVED BY A MORE PRECISE CUTOFF
	}
	
	// GENERATE PITCHOVER LIMIT (ADDS BASIC OPEN LOOP SECTION)
	LOCAL PITCH_GRADIENT IS MIN(1,MAX(0, (ALTITUDE-6000)/(15000-6000)  )).
	LOCAL PITCH_MAX IS 80 - 20*PITCH_GRADIENT.
	
	// GENERATE TARGET YAW COMMAND (FIXME)
	LOCAL YAW IS 90.
	
	// STEER THE VEHICLE. ANGLE LIMITS MAINTAINED TO PREVENT GUIDANCE FROM
	// 	COMMANDING REALLY SUBOPTIMAL HIGH ANGLES
	SET CURRENT_STEERING TO HEADING(YAW, MIN(PITCH_MAX,MAX(-60, PITCH ))).
	
	//--------------------------------------------------------------------------
	// SHOW UI VARIABLES
	UI_VARIABLE("F", "", F, 		3,6, SIGNED, 19,7).
	UI_VARIABLE("P", "", PITCH, 	1,6, SIGNED, 19,8).
	UI_VARIABLE("Y", "", YAW, 		1,6, SIGNED, 19,9).
	
	// RUN MINOR LOOP AT HIGH RATE
	TASK_SCHEDULE(1, MM4_MINOR_LOOP_TASK@).
}


////////////////////////////////////////////////////////////////////////////////
// THROTTLE LOOP: MANAGES THE ENGINE THROTTLE TO MAINTAIN STAGE LIMITS
////////////////////////////////////////////////////////////////////////////////
FUNCTION MM4_THROTTLE_TASK { PARAMETER DT.	
	//IF MINOR_MODE = 1 { // ENGINE CHECK
	//	SET CURRENT_THROTTLE TO MIN(1.0, MODE_TIMER()/3.0).
	//	
	//} ELSE IF (MINOR_MODE > 1) AND (MINOR_MODE < 8) { // FLIGHT THROTTLE
	//	// LIMIT MAX THROTTLE BASED ON ACCELERATION
	//	IF SHIP:SENSORS:ACC:MAG > 16.0 {
	//		SET MAX_THROTTLE TO MAX(0.35, MAX_THROTTLE - MM4_THROTTLE_DRATE*DT).
	//	}
	//	
	//	// DEFINE DECREASE IN THROTTLE DUE TO HIGH Q
	//	LOCAL Q_THROTTLE IS MIN(MAX((SHIP:Q - 0.15)/0.05, 0), 0.50).
	//
	//	// SET THROTTLE LEVEL
	//	SET CURRENT_THROTTLE TO MIN(1.0 - Q_THROTTLE, MAX_THROTTLE).
	//	
	//} ELSE { // OTHER MODES
	//	SET CURRENT_THROTTLE TO 0.0.
	//}
	
	SET CURRENT_THROTTLE TO 1.0.
	
	IF MINOR_MODE = 1 {
		TASK_SCHEDULE(1, MM4_THROTTLE_TASK@).
	} ELSE {
		TASK_SCHEDULE(3, MM4_THROTTLE_TASK@).
	}
}.


////////////////////////////////////////////////////////////////////////////////
// FEED TELEMETRY TO DATA RECORDER/DOWNLINK
////////////////////////////////////////////////////////////////////////////////
FUNCTION MM4_TELEMETRY_TASK { PARAMETER DT.
	//DOWNLINK("PITCH   ",ROUND(PITCH_COMMAND,3) ).
	//DOWNLINK("Q",		ROUND(SHIP:Q*100,3) ).
	//DOWNLINK("THRUST",	ROUND(MAXTHRUST,1) ).
	//DOWNLINK("MASS",	ROUND(MASS,2) ).
	//DOWNLINK("AP",		ROUND(SHIP:APOAPSIS,0) ).
	//DOWNLINK("PE",		ROUND(SHIP:PERIAPSIS,0) ).
	//DOWNLINK("TRIM",	ROUND(SERVO_GET("Main engine"),2) ).
	//DOWNLINK("ABORT",	ABORT_TYPE ).
	
	TASK_SCHEDULE(7, MM4_TELEMETRY_TASK@).
}.




////////////////////////////////////////////////////////////////////////////////
MODE_NAMES:ADD(40, "CONSTANT THRUST ").
MODE_NAMES:ADD(41, "CONSTANT ACCEL  ").

MODE_ENTER		(4, MM4_ENTER@).
MODE_LEAVE		(4, MM4_LEAVE@).
MODE_TASK		(4, MM4_MAJOR_LOOP_TASK@).
MODE_TASK		(4, MM4_MINOR_LOOP_TASK@).
//MODE_TASK		(4, MM4_THROTTLE_TASK@).
//MODE_TASK		(4, MM4_TELEMETRY_TASK@).