////////////////////////////////////////////////////////////////////////////////
//	OV		MAJOR MODE 6 (REENTRY)
////////////////////////////////////////////////////////////////////////////////
FUNCTION MM6_ENTER {
	// INITIALIZE DRAG CONTROLLERS
	GLOBAL HDRAG_CONTROLLER TO PIDLOOP(0.350,	0.050,	0.150,	-10.0,	7.5).
	GLOBAL VDRAG_CONTROLLER TO PIDLOOP(2.000,	0.050,	2.000,	-35.0,	15.0).
	
	// INITIALIZE EXTRA VARIABLES
	GLOBAL PREVIOUS_AIRSPEED TO AIRSPEED.
	GLOBAL MACH TO 7.
	
	// ROLL REVERSAL SUPPORT
	GLOBAL ROLL_SIGN TO 1. // FIXME: DETERMINE FROM BODY ANGLES
	GLOBAL ROLL_REVERSAL_THRESHOLD TO 0.01.
	GLOBAL ROLL_REVERSAL_PARAM TO 0.
	GLOBAL ROLL_RATE_MOD TO 1.
	
	// STEERING
	GLOBAL ROLL_CMD TO ROLL_SIGN*70.
	GLOBAL PITCH_CMD TO MM6_MAX_ALPHA.
	SET CURRENT_STEERING TO HEADING(90,0).
	ENABLE_STEERING().

	// RESET DOWNRANGE ESTIMATION
	GLOBAL DR_DT TO 0.
	GLOBAL EI_ESTIMATE TO TIME:SECONDS.
	GLOBAL EI_DOWNRANGE TO 0.
	
	// RESET GUIDANCE PARAMETERS
	GLOBAL DRAG_CUR TO -0.01.
	GLOBAL T0 TO 0.
	GLOBAL T TO 0.
	GLOBAL VV_REF TO 0.
	GLOBAL MIN_ALPHA TO MM6_MIN_ALPHA2.
	GLOBAL VDRAG_DELTA TO 0.
	GLOBAL HDRAG_DELTA TO 0.
	GLOBAL V TO 0.
		
	// TARGET ENTRY DELTA-V
	//GLOBAL ENTRY_T TO 0.
	//GLOBAL ENTRY_DV TO GET_PVAR("ENTRY_DV", -100).
	//GLOBAL ENTRY_NODE TO NODE(TIME:SECONDS, 0, 0, 0).
	
	// MODE TRANSFER TO RE-ENTRY
	IF (MINOR_MODE = 0) AND (SHIP:PERIAPSIS < 70000) {
		//TRANSFER_MODE(6,3).
	}
}

FUNCTION MM6_LEAVE {
	DISABLE_STEERING().
}

FUNCTION MM6_TRANSFER {
	IF MINOR_MODE = 0 { // ENSURE BURN TASK IS ACTIVE
		TASK_SCHEDULE(1, MM6_BURN_TASK@).
	}
	IF MINOR_MODE = 3 { // ENSURE RE-ENTRY TASK IS ACTIVE
		TASK_SCHEDULE(1, MM6_REENTRY_TASK@).
	}
}

FUNCTION MM6_COMMAND {
	PARAMETER VERB, VALUE.

	IF VERB = 1 { // SET ENTRY DV
		//IF HASNODE {
		//	REMOVE NEXTNODE.
		//}
		//SET ENTRY_NODE TO NODE(TIME:SECONDS + 
		//SET ENTRY_DV TO VALUE.
		//SET_PVAR(ENTRY_DV, VALUE).
	}
	IF VERB = 3 { // RESET EI CALCULATION
		SET EI_ESTIMATE TO TIME:SECONDS + VALUE.
	}
}

//
// BURN TASK. CURRENTLY BURNS ARE MANUAL THOUGH
//
FUNCTION MM6_BURN_TASK { PARAMETER DT.
	IF MINOR_MODE <= 2 {
		TASK_SCHEDULE(1, MM6_BURN_TASK@).
	}

	// ESTIMATE DOWNRANGE AT WHICH EI IS LOCATED
	LOCAL DT0 IS 1.0.
	LOCAL R1 IS (SHIP:BODY:ALTITUDEOF(POSITIONAT(SHIP, EI_ESTIMATE - DT0)) - 70000)^2.
	LOCAL R2 IS (SHIP:BODY:ALTITUDEOF(POSITIONAT(SHIP, EI_ESTIMATE + DT0)) - 70000)^2.
	SET DR_DT TO 0.00001*(R2 - R1)/DT0.
	SET EI_ESTIMATE TO MAX(TIME:SECONDS, EI_ESTIMATE - DR_DT*0.10).
	IF SHIP:PERIAPSIS > 60000 {
		SET EI_ESTIMATE TO TIME:SECONDS.
	}
	
	// CALCULATE EI DOWNRANGE
	LOCAL EI_POSITION TO SHIP:BODY:GEOPOSITIONOF(POSITIONAT(SHIP, EI_ESTIMATE)).
	
	// ESTIMATE WITH EQUIRECTANGULAR APPROXIMATION
	LOCAL L1 IS CONSTANT:PI*(EI_POSITION:LNG - RUNWAY:LNG)/180.0.
	LOCAL F1 IS CONSTANT:PI*(EI_POSITION:LAT + RUNWAY:LAT)/180.0.
	LOCAL F2 IS CONSTANT:PI*(EI_POSITION:LAT - RUNWAY:LAT)/180.0.
	LOCAL X IS L1*COS(F1/2).
	LOCAL Y IS F2.
	SET EI_DOWNRANGE TO SQRT(X^2 + Y^2)*BODY("KERBIN"):RADIUS.

	//SET EI_DOWNRANGE TO ABS( BODY("KERBIN"):RADIUS * CONSTANT:PI*(EI_POSITION:LNG - RUNWAY:LNG)/180.0 ).
	
	// SET STEERING
	IF MINOR_MODE <= 2 {
		SET CURRENT_STEERING TO -SHIP:VELOCITY:SURFACE.
	}
}

//
// PERFORM A ROLL REVERSAL MODE TRANSITION
//
FUNCTION MM6_ROLL_REVERSAL {
	IF MINOR_MODE = 3 {
		TRANSFER_MODE(6,4).
	} ELSE IF MINOR_MODE = 4 {
		TRANSFER_MODE(6,5).
	} ELSE IF MINOR_MODE = 5 {
		TRANSFER_MODE(6,6).
	}
}

//
// RE-ENTRY TASK
//
FUNCTION MM6_REENTRY_TASK { PARAMETER DT.
	IF MINOR_MODE > 2 {
		TASK_SCHEDULE(1, MM6_REENTRY_TASK@).
	} ELSE {
		TASK_SCHEDULE(8, MM6_REENTRY_TASK@).
	}
	
	//
	// ESTIMATE CURRENT DRAG
	//
	IF DT = INIT {
		SET PREVIOUS_AIRSPEED TO AIRSPEED.
		SET DRAG_CUR TO -0.01.
	} ELSE {
		LOCAL DRAG_A0 TO (AIRSPEED - PREVIOUS_AIRSPEED) / DT.
		SET PREVIOUS_AIRSPEED TO AIRSPEED.
		SET DRAG_CUR TO DRAG_CUR*0.92 + 0.08*MIN(-0.01, DRAG_A0).
	}
	
	// BASIC EQUATIONS
	//		DISTANCE AFTER TIME T:
	//	D = V T + A T^2/2
	//		ACCELERATION FOR BRAKING FROM DISTANCE D OVER TIME T FROM SPEED V:
	//	A = 2*(D - V*T)/(T^2)
	//		ALTITUDE CHANGE AFTER TIME T WITH VERTICAL VELOCITY VV:
	//	H = -VV * T
	//		TIME TO PASS DISTANCE D WITH STARTING SPEED V, DECELERATION A
	//	T = (-V +- SQRT(V*V - 2*A*D))/A
	
	// DISTANCE TO REENTRY TARGET POINT
	LOCAL D  TO MAX(0, RUNWAY:DISTANCE - MM6_TARGET_DISTANCE).
	// VELOCITY RESIDUAL TO TARGET POINT
	SET   V  TO AIRSPEED - MM6_TARGET_SPEED.
	// ALTITUDE RESIDUAL TO TARGET POINT
	LOCAL H  TO ALTITUDE - MM6_TARGET_ALT.
	
	
	// REFERENCE TIME TO TARGET POINT (DISTANCE-BASED TIME)
	//
	//	THIS TIME INDICATES IN HOW MANY SECONDS THE TARGET POINT WOULD BE
	//	REACHED IF THE CURRENT DRAG LEVEL REMAINS THE SAME. THIS VALUE IS
	//	USED AS AN APPROXIMATION OF TRAVEL TIME REMAINING ON THE RE-ENTRY
	//	PROFILE BASED ON VEHICLE MOTION
	//
	//	THIS VALUE IS USEFUL AS IT GRADUALLY DECREASES OVER TIME WITHOUT
	//	SIGNIFICANT IMPACT FROM THE VEHICLE TRAJECTORY, BUT VEHICLE
	//	STILL AFFECTS IT BY ITS PERFORMANCE (CURRENT DRAG IS USED AS AN
	//	APPROXIMATION FOR TRAJECTORY DRAG).
	//
	SET T0 TO MAX(1,  -(-V + SQRT(MAX(0,V*V - 2*DRAG_CUR*D)))/DRAG_CUR ).
	
	
	// REFERENCE TIME TO TARGET POINT (VELOCITY-BASED TIME)
	//
	//	THIS TIME INDICATES HOW MANY SECONDS ARE LEFT UNTIL ZERO VELOCITY
	//	RESIDUALS ARE REACHED. THIS IS USED AS THE CONTROL PARAMETER FOR
	//	THE RE-ENTRY AS THIS VALUE HIGHLY DEPENDS ON CURRENT DRAG VALUE
	//	AND IS SIGNIFICANTLY MORE SENSITIVE TO VEHICLE DRAGON THAN T0.
	//
	//	TERMINAL GUIDANCE IS FORMULATED AS BOTH T0 AND T CONVERGING TO ZERO
	//	AT THE TARGET POINT. ITERATIVELY THE VEHICLE ATTEMPTS TO MATCH
	//	CURRENT VELOCITY DECREASE WITH THE CURRENT DISTANCE DECREASE BY
	//	BALLANCING T0 AGAINST T.
	//
	SET T  TO MAX(15, -V/DRAG_CUR ).


	//
	// REFERENCE VERTICAL SPEED
	//
	//	THIS SIMPLY ATTEMPTS TO COMPUTE SUCH VERTICAL SPEED VV_REF THAT
	//	THE SPACECRAFT WOULD END UP WITH ZERO RESIDUAL ALTITUDE WHEN
	//	T0 REACHES ZERO.
	//
	//	AN ADDITIONAL COMPENSATION IS ADDED TO ACCOUNT (SOMEWHAT) FOR
	//	ROLL REVERSALS INTRODUCING A LARGE POSITIVE BIAS TO ALTITUDE.
	//
	//	THE REFERENCE ALTITUDE IS LIMITED TO AT LEAST -25 M/S DESCENT
	//	SO SPACECRAFT MAINTAINS ENERGY IN CASE OF SEVERE UNDERSHOOT, TO
	//	PERMIT CREW DECISION AND POSSIBLE TRANSITION TO AN ABORT MODE
	//	WITH ENOUGH ENERGY.
	//
	SET VV_REF TO MIN(-25, -H/T0 + MM6_VV_COMPENSATION).
	
	//
	// SHOULD GUIDANCE TRANSFER TO LANDING
	//
	//	THIS DECISION IS MADE BASED ON OVERSHOOT THRESHOLD OR SIMPLY
	//	REACHING ZERO RESIDUAL VELOCITY.
	//
	IF (V < 0) OR (RUNWAY:DISTANCE < MM6_TARGET_DISTANCE*0.80) {
		TRANSFER_MODE(3,1).
	}

	//
	// IS ROLL REVERSAL REQUIRED
	//
	//	ROLL REVERSAL LOGIC IS ONLY ENABLED BELOW 70000 M, ALTHOUGH
	//	INITIAL ANGLE SELECTION IS MADE BEFORE 70000 M WHEN SPACECRAFT
	//	TRANSITIONS FROM IDLE ATTITUDE.
	//
	IF ALTITUDE < 70000 {
		IF (ROLL_REVERSAL_PARAM > ROLL_REVERSAL_THRESHOLD) AND (ROLL_SIGN = -1) {
			SET ROLL_SIGN TO 1.
			MM6_ROLL_REVERSAL().
		}
		IF (ROLL_REVERSAL_PARAM < -ROLL_REVERSAL_THRESHOLD) AND (ROLL_SIGN = 1) {
			SET ROLL_SIGN TO -1.
			MM6_ROLL_REVERSAL().
		}
	} ELSE {
		// DETERMINE INITIAL ROLL
		IF ROLL_REVERSAL_PARAM > 0 {
			SET ROLL_SIGN TO 1.
		} ELSE {
			SET ROLL_SIGN TO -1.
		}
	}

	//
	// COMPUTE DRAG ERROR (VERTICAL, HORIZONTAL)
	//
	SET VDRAG_DELTA TO VV_REF - VERTICALSPEED.
	SET HDRAG_DELTA TO T0 - T.
	
	//
	// MODULATE ANGLE OF ATTACK TO CONTROL DRAG
	//
	LOCAL TGT_PITCH_CMD IS MAX(MIN_ALPHA, MM6_AVERAGE_ALPHA + HDRAG_CONTROLLER:UPDATE(TIME:SECONDS, HDRAG_DELTA) ).
	
	//
	// MODULATE VERTICAL VELOCITY TO CONTROL DESCENT SPEED (AND INDIRECTLY DRAG)
	//
	LOCAL TGT_ROLL_CMD IS ROLL_SIGN*( 70 + VDRAG_CONTROLLER:UPDATE(TIME:SECONDS, VDRAG_DELTA) ).
	
	//
	// WHEN STILL IN SPACE, DO NOT GENERATE ROLL COMMANDS
	//
	IF ALTITUDE > 70000 {
		SET TGT_ROLL_CMD TO 0.
	}
	
	//
	// RATE LIMIT THE ROLL COMMAND. REDUCE THE ROLL RATE FOR SMALL ERRORS
	//
	IF ABS(ROLL_CMD - TGT_ROLL_CMD) < 5 {
		IF ROLL_RATE_MOD > 0.60 { // 2-SECOND EASE TO LOWER ROLL RATE
			SET ROLL_RATE_MOD TO MAX(0.60, ROLL_RATE_MOD - 0.20*DT).
		}
	} ELSE {
		IF ROLL_RATE_MOD < 1.00 { // 4-SECOND EASE TO HIGHER ROLL RATE
			SET ROLL_RATE_MOD TO MIN(1.00, ROLL_RATE_MOD + 0.10*DT).
		}
	}	
	IF ROLL_CMD < TGT_ROLL_CMD {
		SET ROLL_CMD TO MIN(TGT_ROLL_CMD, ROLL_CMD + ROLL_RATE_MOD*MM6_ROLL_RATE*DT).
	}
	IF ROLL_CMD > TGT_ROLL_CMD {
		SET ROLL_CMD TO MAX(TGT_ROLL_CMD, ROLL_CMD - ROLL_RATE_MOD*MM6_ROLL_RATE*DT).
	}
	
	//
	// RATE LIMIT THE PITCH COMMAND
	//
	IF PITCH_CMD < TGT_PITCH_CMD {
		SET PITCH_CMD TO MIN(TGT_PITCH_CMD, PITCH_CMD + MM6_PITCH_RATE*DT).
	}
	IF PITCH_CMD > TGT_PITCH_CMD {
		SET PITCH_CMD TO MAX(TGT_PITCH_CMD, PITCH_CMD - MM6_PITCH_RATE*DT).
	}
	
	//
	// STEER SPACECRAFT TO SPECIFIC ALPHA, BETA ANGLES RELATIVE TO VELOCITY VECTOR
	//
	IF MINOR_MODE >= 3 {
		LOCAL TARGET_DIR IS LOOKDIRUP(SHIP:VELOCITY:SURFACE, SHIP:UP:FOREVECTOR).
		SET CURRENT_STEERING TO (TARGET_DIR*R(0,0,-ROLL_CMD))*R(-PITCH_CMD,0,0).
	}
}


//
// TASK WHICH SETS MINIMUM ANGLE OF ATTACK
//
FUNCTION MM6_ALPHA_TASK { PARAMETER DT.
	TASK_SCHEDULE(6, MM6_ALPHA_TASK@).
	
	// GET COARSE MACH NUMBER ESTIMATE
	SET MACH TO 6.8*AIRSPEED/2200.
	
	// CALCULATE MIN ALPHA
	LOCAL TRANSITION IS MIN(1,MAX(0, (MACH - 4.50)/0.4 )).
	SET MIN_ALPHA TO MM6_MIN_ALPHA1 + (MM6_MIN_ALPHA2 - MM6_MIN_ALPHA1)*TRANSITION.
}


//
// ROLL REVERSAL AND BODY FLAP CONTROL TASK
//
FUNCTION MM6_LOW_PRIO_TASK { PARAMETER DT.
	TASK_SCHEDULE(6, MM6_LOW_PRIO_TASK@).
	
	// GET ROLL REVERSAL PARAMETER (FIXME: MAKE THIS BASED ON HEADING)
	SET ROLL_REVERSAL_PARAM TO LATITUDE.
}

FUNCTION MM6_UI_LO_TASK { PARAMETER DT.
	IF DT = INIT {
		HORIZ_LINE(0, 29, 12).
	}
	TASK_SCHEDULE(5, MM6_UI_LO_TASK@).
	
	// GET CENTER OF MASS ESTIMATE
	LOCAL CM TO (SHIP:POSITION - SHIP:ROOTPART:POSITION):MAG.
	LOCAL CM_LIMIT TO CM.
	LOCAL FLAP_POS TO 7.409.
	IF (CM > 7.409) AND (CM <= 7.509) {
		SET FLAP_POS TO 70.0.
	} ELSE IF (CM > 7.509) AND (CM <= 7.748) {
		SET FLAP_POS TO -677.79 + 99.57*CM.
		SET CM_LIMIT TO 7.509.
	} ELSE IF (CM > 7.748) AND (CM <= 7.781) {
		SET FLAP_POS TO -2967.82 + 395.62*CM.
		SET CM_LIMIT TO 7.748.
	} ELSE IF (CM > 7.781) {
		SET CM_LIMIT TO 7.781.	
	}
	
	// DISPLAY BALLANCING INFORMATION
	UI_VARIABLE("      CM",	"M",	CM, 								3,7, SIGNED,	0,0).
	UI_VARIABLE("",			"M",	CM_LIMIT, 							3,7, SIGNED,	19,0).
	UI_VARIABLE("FLAP CMD",	"DEG",	FLAP_POS, 							3,7, SIGNED,	0,1).
	//UI_VARIABLE("FLAP CUR",	"DEG",	SERVO_GET("BODY FLAP"),				3,7, SIGNED,	0,2).
	
	UI_VARIABLE(" ALT",		"M",	ROUND(ALTITUDE/10,0)*10,			0,7, NUMBER,	0,4).
	//UI_VARIABLE(" VEL",		"M/S",	V,									1,7, NUMBER,	0,5).
	UI_VARIABLE("M",		"",		MACH,								3,6, NUMBER,	18,5).
IF MINOR_MODE >= 3 {
	UI_VARIABLE("DIST",		"M",	ROUND(RUNWAY:DISTANCE/100,0)*100,	0,7, NUMBER,	0,6).
}
	UI_VARIABLE("Q",		"KPA",	SHIP:Q*100, 						2,5, NUMBER,	18,6).
	
	// GUIDANCE INFORMATION
	IF MINOR_MODE < 3 {
		//UI_VARIABLE("  EI",	"SEC",	EI_ESTIMATE - TIME:SECONDS, 		1,7, NUMBER,	0,10).
		//UI_VARIABLE("  +X",	"M",	ROUND(EI_DOWNRANGE/100,0)*100, 		1,7, NUMBER,	0,11).
		//UI_VARIABLE("  DX",	"M/S",	DR_DT, 								1,7, SIGNED,	0,12).
		//UI_VARIABLE("  +Z",	"M",	SHIP:BODY:ALTITUDEOF(POSITIONAT(SHIP,EI_ESTIMATE)), 0,7, NUMBER,	0,13).
	} ELSE {
	//IF T < 1000.0 {
	//	UI_VARIABLE("TIME",	"SEC",	T, 									2,7, NUMBER,	0,10).
	//} ELSE {
	//	UI_VARIABLE("TIME",	"SEC",	"-----",							0,7, TEXT,		0,10).
	//}
		//UI_VARIABLE("TREF",	"SEC",	T0, 								2,7, NUMBER,	0,11).
		UI_VARIABLE("DRAG",	"M/S2",	DRAG_CUR, 							2,7, SIGNED,	0,12).
		UI_VARIABLE("VERT",	"M/S",	VERTICALSPEED, 						2,7, SIGNED,	0,13).
		UI_VARIABLE("VREF",	"M/S",	VV_REF, 							2,7, SIGNED,	0,14).
		UI_VARIABLE("RREV",	"",		ROLL_REVERSAL_PARAM, 				2,7, SIGNED,	0,15).
	}
}.

FUNCTION MM6_UI_HI_TASK { PARAMETER DT.
	TASK_SCHEDULE(2, MM6_UI_HI_TASK@).

	UI_VARIABLE("FLAP CUR",	"DEG",	SERVO_GET("BODY FLAP"),				3,7, SIGNED,	0,2).
	UI_VARIABLE(" VEL",		"M/S",	V,									1,7, NUMBER,	0,5).
IF MINOR_MODE < 3 {
	UI_VARIABLE("DIST",		"M",	ROUND(RUNWAY:DISTANCE/100,0)*100,	0,7, NUMBER,	0,6).
}
	IF MINOR_MODE < 3 {
		UI_VARIABLE("  EI",	"SEC",	EI_ESTIMATE - TIME:SECONDS, 		1,7, NUMBER,	0,10).
		UI_VARIABLE("  +X",	"M",	ROUND(EI_DOWNRANGE/100,0)*100, 		1,7, NUMBER,	0,11).
		UI_VARIABLE("  DX",	"M/S",	DR_DT, 								1,7, SIGNED,	0,12).
		UI_VARIABLE("  +Z",	"M",	SHIP:BODY:ALTITUDEOF(POSITIONAT(SHIP,EI_ESTIMATE)), 0,7, NUMBER,	0,13).
	} ELSE {
		IF T < 1000.0 {
			UI_VARIABLE("TIME",	"SEC",	T, 									2,7, NUMBER,	0,10).
		} ELSE {
			UI_VARIABLE("TIME",	"SEC",	"-----",							0,7, TEXT,		0,10).
		}
		UI_VARIABLE("TREF",	"SEC",	T0, 								2,7, NUMBER,	0,11).
	}	
}.

FUNCTION MM6_TELEMETRY_TASK { PARAMETER DT.
	//MADS_TELEMETRY(1, ROUND(T0,2) ).
	//MADS_TELEMETRY(2, ROUND(DRAG_CUR,2) ).
	//MADS_TELEMETRY(3, ROUND(VERTICALSPEED,2) ).
	//MADS_TELEMETRY(4, ROUND(VV_REF,2) ).
	//MADS_TELEMETRY(5, ROUND(CM,3) ).
	//MADS_TELEMETRY(6, ROUND(PITCH_CMD,2) ).
	//MADS_TELEMETRY(7, ROUND(ROLL_CMD,2) ).
	//MADS_TELEMETRY(8, ROUND(T,2) ).
	//MADS_TELEMETRY(9, ROUND(T1,2) ).

	TASK_SCHEDULE(7, MM6_TELEMETRY_TASK@).
}.




////////////////////////////////////////////////////////////////////////////////
MODE_NAMES:ADD(60, "RE-ENTRY MONITOR").
MODE_NAMES:ADD(61, "ENTRY BURN ARMED").
MODE_NAMES:ADD(62, "ENTRY BURN      ").
MODE_NAMES:ADD(63, "RE-ENTRY (REV 1)").
MODE_NAMES:ADD(64, "RE-ENTRY (REV 2)").
MODE_NAMES:ADD(65, "RE-ENTRY (REV 3)").
MODE_NAMES:ADD(66, "RE-ENTRY (REV 4)").

VERB_NAMES:ADD(61, "ENTRY DV").
VERB_NAMES:ADD(62, "ENTRY TIME").
VERB_NAMES:ADD(63, "RESET EI CALC").

MODE_ENTER		(6, MM6_ENTER@).
MODE_TRANSFER	(6, MM6_TRANSFER@).
MODE_LEAVE		(6, MM6_LEAVE@).
MODE_COMMAND	(6, MM6_COMMAND@).

MODE_TASK		(6, MM6_BURN_TASK@).
MODE_TASK		(6, MM6_REENTRY_TASK@).
MODE_TASK		(6, MM6_ALPHA_TASK@).
MODE_TASK		(6, MM6_LOW_PRIO_TASK@).
MODE_TASK		(6, MM6_UI_LO_TASK@).
MODE_TASK		(6, MM6_UI_HI_TASK@).
MODE_TASK		(6, MM6_TELEMETRY_TASK@).
